---
layout: default
title: "Understanding APIs â€“ How Applications Talk"
date: 2025-08-12
categories: [automation-adventures]
description: A beginner-friendly explanation of APIs with a real-world example.
--- 

An **API** (Application Programming Interface) allows two applications to communicate and share data with each other.  
Think of it as a **waiter in a restaurant** â€” taking your request, delivering it to the kitchen, and bringing back your order.

---

<figure>
  <img src="{{ site.baseurl}}/assets/img/api1.png" alt="API basics infographic" style="max-width: 800px; width: 100%;">
  <figcaption><em>How an API request flows from the client â†’ server â†’ response.</em></figcaption>
</figure>

---
## ğŸ” **Key Points About APIs**
- **Purpose:** Enable communication between software systems.
- **Format:** Often uses JSON or XML to exchange data.
- **Types:** REST, SOAP, GraphQL, WebSocket, etc.
- **Security:** Often uses API keys, tokens, or OAuth.

---

## ğŸ“Œ **Example: Weather App**
- You open a weather app and search for â€œMelbourne.â€
- The app sends a request to a **Weather API** with your location.
- The API connects to a weather database, fetches the data, and sends it back.
- Your app displays the temperature, humidity, and forecast.

---

âœ… **Why APIs Are Important**
- Allow integration between different services (e.g., PayPal payments on e-commerce sites).
- Save time â€” developers donâ€™t need to build everything from scratch.
- Support automation and scalability.

---
**How a Real-World API Works**

A production API usually has more than one server. Below is a typical **medium-complexity** layout with an API gateway, authentication, microservices, cache, database, and asynchronous jobs.

<figure>
  <img src="{{ site.baseurl}}/assets/img/apicomplex.png"
       alt="Medium complexity API: client â†’ CDN & API gateway â†’ auth â†’ rate limit â†’ microservices with cache/DB/queue â†’ third-party APIs"
       style="max-width: 1000px; width: 100%;">
  <figcaption><em>High-level view: gateway & auth up front, services in the middle, data stores and async jobs behind them.</em></figcaption>
</figure>

---

## ğŸ§­ Components (quick tour)

- **Client** â€“ browser or mobile app calling the API.
- **CDN** â€“ serves static assets (images, JS) close to the user.
- **API Gateway** â€“ single entry; routes requests to services, enforces policies.
- **Auth Service** â€“ verifies tokens (JWT/OAuth), issues/refreshes tokens.
- **Rate Limiter** â€“ protects the platform from abuse; per-IP/user limits.
- **Service Layer** â€“ domain microservices (e.g., Users, Orders, Payments).
- **Cache** â€“ fast reads for hot data (e.g., Redis).
- **Database** â€“ system of record (e.g., Postgres).
- **Message Queue / Worker** â€“ async jobs (emails, webhooks, reports).
- **Third-Party APIs** â€“ payments, maps, email, etc.

---

## ğŸš— Example flow: booking a ride

1. **Login** â€“ The app sends credentials; **Auth** issues a JWT.
2. **Create ride** â€“ The app calls `POST /rides`.  
   The **API Gateway** authenticates the JWT and checks **rate limits**.
3. **Route to service** â€“ Gateway forwards to **Rides Service**.
4. **Validate & read data** â€“ Rides Service fetches rider & driver profiles;  
   first checks **Cache**, then **DB** if needed (and populates cache).
5. **Call third-party** â€“ Rides Service asks the **Maps API** for ETA and distance.
6. **Write data** â€“ It creates a ride record in the **DB**.
7. **Async work** â€“ It enqueues messages to **Queue** for:  
   - push notification to driver,  
   - trip confirmation email,  
   - analytics event.
8. **Response** â€“ Gateway returns a 201 response with ride details to the client.
9. **Background processing** â€“ **Workers** send notifications and webhooks without blocking the user.
10. **Subsequent reads** â€“ App polls `GET /rides/{id}`; results now hit **Cache** for speed.

---

## âœ… Why this design?

- **Security first** â€“ gateway + auth + rate limiting at the edge.  
- **Performance** â€“ cache for hot data, CDN for static assets.  
- **Reliability** â€“ async jobs keep the API fast and resilient.  
- **Scalability** â€“ separate services can scale independently.  
- **Integrations** â€“ third-party APIs are isolated behind services/workers.

---

