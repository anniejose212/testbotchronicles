---
layout: default
title: "Understanding APIs – How Applications Talk"
date: 2025-08-12
categories: [automation-adventures]
description: A beginner-friendly explanation of APIs with a real-world example.
--- 

An **API** (Application Programming Interface) allows two applications to communicate and share data with each other.  
Think of it as a **waiter in a restaurant** — taking your request, delivering it to the kitchen, and bringing back your order.

---

<figure>
  <img src="{{ site.baseurl}}/assets/img/api1.png" alt="API basics infographic" style="max-width: 800px; width: 100%;">
  <figcaption><em>How an API request flows from the client → server → response.</em></figcaption>
</figure>

---
## 🔍 **Key Points About APIs**
- **Purpose:** Enable communication between software systems.
- **Format:** Often uses JSON or XML to exchange data.
- **Types:** REST, SOAP, GraphQL, WebSocket, etc.
- **Security:** Often uses API keys, tokens, or OAuth.

---

## 📌 **Example: Weather App**
- You open a weather app and search for “Melbourne.”
- The app sends a request to a **Weather API** with your location.
- The API connects to a weather database, fetches the data, and sends it back.
- Your app displays the temperature, humidity, and forecast.

---

✅ **Why APIs Are Important**
- Allow integration between different services (e.g., PayPal payments on e-commerce sites).
- Save time — developers don’t need to build everything from scratch.
- Support automation and scalability.

---
**How a Real-World API Works**

A production API usually has more than one server. Below is a typical **medium-complexity** layout with an API gateway, authentication, microservices, cache, database, and asynchronous jobs.

<figure>
  <img src="{{ site.baseurl}}/assets/img/apicomplex.png"
       alt="Medium complexity API: client → CDN & API gateway → auth → rate limit → microservices with cache/DB/queue → third-party APIs"
       style="max-width: 1000px; width: 100%;">
  <figcaption><em>High-level view: gateway & auth up front, services in the middle, data stores and async jobs behind them.</em></figcaption>
</figure>

---

## 🧭 Components (quick tour)

- **Client** – browser or mobile app calling the API.
- **CDN** – serves static assets (images, JS) close to the user.
- **API Gateway** – single entry; routes requests to services, enforces policies.
- **Auth Service** – verifies tokens (JWT/OAuth), issues/refreshes tokens.
- **Rate Limiter** – protects the platform from abuse; per-IP/user limits.
- **Service Layer** – domain microservices (e.g., Users, Orders, Payments).
- **Cache** – fast reads for hot data (e.g., Redis).
- **Database** – system of record (e.g., Postgres).
- **Message Queue / Worker** – async jobs (emails, webhooks, reports).
- **Third-Party APIs** – payments, maps, email, etc.

---

## 🚗 Example flow: booking a ride

1. **Login** – The app sends credentials; **Auth** issues a JWT.
2. **Create ride** – The app calls `POST /rides`.  
   The **API Gateway** authenticates the JWT and checks **rate limits**.
3. **Route to service** – Gateway forwards to **Rides Service**.
4. **Validate & read data** – Rides Service fetches rider & driver profiles;  
   first checks **Cache**, then **DB** if needed (and populates cache).
5. **Call third-party** – Rides Service asks the **Maps API** for ETA and distance.
6. **Write data** – It creates a ride record in the **DB**.
7. **Async work** – It enqueues messages to **Queue** for:  
   - push notification to driver,  
   - trip confirmation email,  
   - analytics event.
8. **Response** – Gateway returns a 201 response with ride details to the client.
9. **Background processing** – **Workers** send notifications and webhooks without blocking the user.
10. **Subsequent reads** – App polls `GET /rides/{id}`; results now hit **Cache** for speed.

---

## ✅ Why this design?

- **Security first** – gateway + auth + rate limiting at the edge.  
- **Performance** – cache for hot data, CDN for static assets.  
- **Reliability** – async jobs keep the API fast and resilient.  
- **Scalability** – separate services can scale independently.  
- **Integrations** – third-party APIs are isolated behind services/workers.

---

